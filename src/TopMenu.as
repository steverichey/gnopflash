package{	import flash.display.MovieClip;	import flash.display.Sprite;	import flash.events.Event;	import flash.events.MouseEvent;	import flash.events.TimerEvent;	import flash.utils.Timer;	import flash.display.Bitmap;	import flash.geom.ColorTransform;	import flash.text.TextField;	import flash.text.TextFormat;	import flash.text.GridFitType;	import flash.text.AntiAliasType;		public class TopMenu extends MovieClip	{		public var publicUsability:Boolean;		private var animateTimer:Timer;		private var thisX:uint;		private var thisY:uint;		private var animatedItem:Object;				[Embed(source = "data/tiny_icon.png")] public var TinyIcon:Class;		private var tinyIcon:Bitmap = new TinyIcon();				private var invisibleBG:Sprite;				private var headerList:Array;		private var headerContainer:Array;		private var dropmenuContainer:Array;				private var dropmenuList:Array;				// Only needed six headers in this case, but future applications could use more, if needed.		// These names were originally dynamically generated based on the desired names of each header, but that was broken.				private var headerItem0:MenuItem;		private var headerItem1:MenuItem;		private var headerItem2:MenuItem;		private var headerItem3:MenuItem;		private var headerItem4:MenuItem;		private var headerItem5:MenuItem;				// Six headers means six drop menus.				private var dropMenu0:DropMenu;		private var dropMenu1:DropMenu;		private var dropMenu2:DropMenu;		private var dropMenu3:DropMenu;		private var dropMenu4:DropMenu;		private var dropMenu5:DropMenu;				public function TopMenu()		{			if ( stage )			{				onAddtoStage();			}			else			{				addEventListener( Event.ADDED_TO_STAGE, onAddtoStage, false, 0, true );			}		}				public function onAddtoStage( e:Event = null ):void		{			removeEventListener( Event.ADDED_TO_STAGE, onAddtoStage );						headerList = new Array();						for ( var b:uint = 0; b <= XMLContainer.defaultXML.menu.dropmenu.length() - 1; b++ )			{				headerList.push( XMLContainer.defaultXML.menu.dropmenu.@header[b] );			}						dropmenuList = new Array();						for ( var i:uint = 0; i <= headerList.length - 1; i++ )			{				var temp:Array = new Array();								for ( var c:uint = 0; c <= XMLContainer.defaultXML.menu.dropmenu[i].item.length() - 1; c++ )				{					temp.push( XMLContainer.defaultXML.menu.dropmenu[i].item.@value[c] );				}								dropmenuList.push( temp ); // This array of arrays holds drop menu item names.			}						// Makes the big red "InvisibleBG" item truly invisible, then adds a mouse listener to detect clicks.			// This removes drop menus when the user clicks "away" from the menu.						invisibleBG = new Sprite();			invisibleBG.graphics.beginFill( 0xFF0000 );			invisibleBG.graphics.drawRect( 0, 0, 640, 480 );			invisibleBG.graphics.endFill();			invisibleBG.x = 0;			invisibleBG.y = 0;			invisibleBG.alpha = 0;			addChild( invisibleBG );						// Draw the small upper-right GNOP! icon.						tinyIcon.x = 609;			tinyIcon.y = 5;			addChild( tinyIcon );						// Draw header items.						headerContainer = new Array();						for ( var a:uint = 0; a <= headerList.length - 1; a++)			{				var tempField:TextField = new TextField();				tempField.embedFonts = true;				tempField.defaultTextFormat = new TextFormat( "chicago", 12, 0x000000, null, null, null, null, null, "left" );				tempField.gridFitType = GridFitType.PIXEL;				tempField.antiAliasType = AntiAliasType.ADVANCED;				tempField.thickness = 0;				tempField.sharpness = 0;				tempField.text = headerList[a];				var tempWidth:uint;								// Unless it's the Septagon header item, header width is based on text width.								if ( headerList[a] != "SEPTAGON" )				{					tempWidth = tempField.textWidth + 18;				}				else				{					tempWidth = 29;				}								this[ "headerItem" + a.toString() ] = new MenuItem( headerList[a], tempWidth, true, a, 0, XMLContainer.defaultXML.menu..display.@textcolor, XMLContainer.defaultXML.menu..display.@bgcolor );								// Unless this is the first header item, put the item next to the previous item.								if ( a > 0 )				{					// Technically, this should have a "- 5" at the end, but that doesn't work, as they overlap. The original					// OS had 10px of extra space on each side of the highlighted item, but if you moved the mouse to the outer					// 5px of that space, you would select the next header.										this[ "headerItem" + a.toString() ].x = this[ "headerItem" + ( a - 1 ).toString() ].x + this[ "headerItem" + ( a - 1 ).toString() ].width;				}				else				{					this[ "headerItem" + a.toString() ].x = 9;				}								this[ "headerItem" + a.toString() ].y = 1;				addChild( this[ "headerItem" + a.toString() ] );								headerContainer.push( this[ "headerItem" + a.toString() ] );			}						// Create drop menus. They're hidden, but will be visible when the appropriate header is clicked.						dropmenuContainer = new Array();						for ( var o:uint = 0; o <= headerList.length - 1; o++)			{				this[ "dropMenu" + o.toString() ] = new DropMenu( dropmenuList[o], headerList[o], o, XMLContainer.defaultXML.menu.display.@textcolor, XMLContainer.defaultXML.menu..display.@bgcolor );				this[ "dropMenu" + o.toString() ].x = headerContainer[o].x;				this[ "dropMenu" + o.toString() ].y = 19;				this[ "dropMenu" + o.toString() ].visible = false;				addChild( this[ "dropMenu" + o.toString() ] );								dropmenuContainer.push( this[ "dropMenu" + o.toString() ] );			}						publicUsability = false; // This gets reversed to true below when we setUsability to true.						// Sets the usability of the menu to true; that is, the header items have mouse click listeners.						setUsability( true );						updateCheckmarks();		}				public function setUsability( desiredUsability:Boolean ):void  // Toggle header listeners		{			if ( desiredUsability && !publicUsability )			{				for ( var i:uint = 0; i <= headerContainer.length - 1; i++)				{					headerContainer[i].addEventListener( MouseEvent.MOUSE_DOWN, onDownHeader, false, 0, true );				}								invisibleBG.addEventListener( MouseEvent.MOUSE_DOWN, onClickAway, false, 0, true );								publicUsability = true;			}			else if ( !desiredUsability && publicUsability )			{				for ( var o:uint = 0; o <= headerContainer.length - 1; o++)				{					headerContainer[o].removeEventListener( MouseEvent.MOUSE_DOWN, onDownHeader );				}								invisibleBG.removeEventListener( MouseEvent.MOUSE_DOWN, onClickAway );								publicUsability = false;			}		}				public function onDownHeader( e:MouseEvent ):void		{			if ( !e.currentTarget.isInverted )			{				e.currentTarget.invertThis();								dropmenuContainer[ e.currentTarget.headerNumber ].visible = true;				addDropListeners( dropmenuContainer[ e.currentTarget.headerNumber ] );								for ( var o:uint = 0; o <= dropmenuContainer[ e.currentTarget.headerNumber.toString() ].contentList.length - 1; o++ )				{					//dropmenuContainer[ e.currentTarget.headerNumber.toString() ][o]				}								for ( var i:uint = 0; i <= headerContainer.length - 1; i++)				{					headerContainer[i].addEventListener( MouseEvent.ROLL_OVER, onRollHeader, false, 0, true );				}			}			else			{				e.currentTarget.resetThis();								for ( var x:uint = 0; x <= headerContainer.length - 1; x++)				{					headerContainer[x].removeEventListener( MouseEvent.ROLL_OVER, onRollHeader );					dropmenuContainer[x].visible = false;				}			}		}				public function onRollHeader( e:MouseEvent ):void		{			// We ignore most of this if the header item isn't inverted; this just means that the user has moved the mouse back			// up to the top of the active drop menu, and we don't want to do anything in that case except clear the			// visible drop menu of inverted items.						if ( !e.currentTarget.isInverted )			{				cleanVisibleDrops();								for ( var i:uint = 0; i <= headerContainer.length - 1; i++)				{					headerContainer[i].resetThis();					dropmenuContainer[i].visible = false;					removeDropListeners( dropmenuContainer[i] );				}								e.currentTarget.invertThis();				dropmenuContainer[ e.currentTarget.headerNumber ].visible = true;				addDropListeners( dropmenuContainer[ e.currentTarget.headerNumber ] );			}			else			{				for ( var o:uint = 0; o <= dropmenuContainer[ e.currentTarget.headerNumber ].menuitemContainer.length - 1; o++ )				{					dropmenuContainer[ e.currentTarget.headerNumber ].menuitemContainer[o].resetThis();				}			}		}				public function cleanVisibleDrops():void		{			// Find the visible drop menu, and reset (make non-inverted) its menu items.								for ( var a:uint = 0; a <= headerContainer.length - 1; a++ )				{					if ( dropmenuContainer[a].visible == true )					{						for ( var x:uint = 0; x <= dropmenuContainer[a].menuitemContainer.length - 1; x++ )						{							dropmenuContainer[a].menuitemContainer[x].resetThis();						}					}				}		}				public function onClickAway( e:MouseEvent = null ):void		{			var o:Array = new Array();						for ( var a:uint = 0; a <= dropmenuContainer.length - 1; a++ )			{				o.push( dropmenuContainer[a].visible );			}						for ( var i:uint = 0; i <= headerContainer.length - 1; i++)			{				headerContainer[i].resetThis();				dropmenuContainer[i].visible = false;				removeDropListeners( dropmenuContainer[i] );			}						removeRollListeners();		}				public function removeRollListeners():void		{			for ( var i:uint = 0; i <= headerContainer.length - 1; i++)			{				headerContainer[i].removeEventListener( MouseEvent.ROLL_OVER, onRollHeader );			}		}				public function addDropListeners( d:DropMenu ):void		{			for ( var i:uint = 0; i <= d.menuitemContainer.length - 1; i++ )			{				d.menuitemContainer[i].addEventListener( MouseEvent.ROLL_OVER, onRollDropItem, false, 0, true );				d.menuitemContainer[i].addEventListener( MouseEvent.MOUSE_UP, onUpDropItem, false, 0, true );				d.menuitemContainer[i].addEventListener( MouseEvent.ROLL_OUT, onOutDropItem, false, 0, true );			}		}				public function removeDropListeners( d:DropMenu ):void		{			for ( var i:uint = 0; i <= d.menuitemContainer.length - 1; i++ )			{				d.menuitemContainer[i].removeEventListener( MouseEvent.ROLL_OVER, onRollDropItem );				d.menuitemContainer[i].removeEventListener( MouseEvent.MOUSE_UP, onUpDropItem );				d.menuitemContainer[i].removeEventListener( MouseEvent.ROLL_OUT, onOutDropItem );			}		}				public function onRollDropItem( e:MouseEvent ):void		{			for ( var i:uint = 0; i <= dropmenuContainer[ e.currentTarget.headerNumber ].menuitemContainer.length - 1; i++ )			{				dropmenuContainer[ e.currentTarget.headerNumber ].menuitemContainer[i].resetThis();			}						e.currentTarget.invertThis();						// Need to make it so the rolled-over header comes to the top, per original OS			//e.currentTarget.parent.setChildIndex( e.currentTarget, e.currentTarget.parent.numChildren - 1);			// This doesn't work.		}				public function dullHeaders():void		{			for ( var i:uint = 0; i <= headerContainer.length - 1; i++ )			{				headerContainer[ i ].transform.colorTransform = new ColorTransform( 1, 1, 1, 1, 136, 136, 136 );			}		}				public function brightHeaders():void		{			for ( var i:uint = 0; i <= headerContainer.length - 1; i++ )			{				headerContainer[ i ].transform.colorTransform = new ColorTransform();			}		}				public function onUpDropItem( e:MouseEvent ):void		{			removeDropListeners( dropmenuContainer[ e.currentTarget.headerNumber ] );			setUsability( false );			removeRollListeners();						// Convert the clicked item to a sort of X,Y position.  So, the first item of the first header is (0,0).			// This third item of the fourth header is (3,2)						thisX = e.currentTarget.headerNumber;			thisY = e.currentTarget.dropNumber;						animatedItem = e.currentTarget;						animateTimer = new Timer( 34, 6 );			animateTimer.addEventListener( TimerEvent.TIMER, onTimer );			animateTimer.addEventListener( TimerEvent.TIMER_COMPLETE, onFinishItemAnimate );			animateTimer.start();		}				public function onTimer( t:TimerEvent ):void		{			if ( animatedItem.isInverted )			{				animatedItem.resetThis();			}			else			{				animatedItem.invertThis();			}		}				public function onFinishItemAnimate( t:TimerEvent ):void		{			animateTimer = null;						var chosenNavigationEvent:NavigationEvent;						setUsability( true );						cleanVisibleDrops();			onClickAway(); // Clears drop menus, resets headers, removes roll mouse event listeners.						switch( true )				{				case thisX == 0 && thisY == 0:					chosenNavigationEvent = new NavigationEvent ( NavigationEvent.ABOUT );					break;				case thisX == 1 && thisY == 0:					chosenNavigationEvent = new NavigationEvent ( NavigationEvent.PLAY );					break;				case thisX == 1 && thisY == 1:					chosenNavigationEvent = new NavigationEvent ( NavigationEvent.QUIT );					break;				case thisX == 2 && thisY == 0:					MovieClip( this.parent ).playerSize = 1;					break;				case thisX == 2 && thisY == 1:					MovieClip( this.parent ).playerSize = 2;					break;				case thisX == 2 && thisY == 2:					MovieClip(this.parent).playerSize = 3;					break;				case thisX == 2 && thisY == 3:					MovieClip(this.parent).enemySize = 1;					break;				case thisX == 2 && thisY == 4:					MovieClip(this.parent).enemySize = 2;					break;				case thisX == 2 && thisY == 5:					MovieClip(this.parent).enemySize = 3;					break;				case thisX == 3 && thisY == 0:					MovieClip(this.parent).ballSize = 1;					break;				case thisX == 3 && thisY == 1:					MovieClip(this.parent).ballSize = 2;					break;				case thisX == 3 && thisY == 2:					MovieClip(this.parent).ballSize = 3;					break;				case thisX == 3 && thisY == 3:					Main.changeBallSpeed( 1 );					break;				case thisX == 3 && thisY == 4:					Main.changeBallSpeed( 2 );					break;				case thisX == 3 && thisY == 5:					Main.changeBallSpeed( 3 );					break;				case thisX == 4 && thisY == 0:					Main.changeDifficulty( 1 );					break;				case thisX == 4 && thisY == 1:					Main.changeDifficulty( 2 );					break;				case thisX == 4 && thisY == 2:					Main.changeDifficulty( 3 );					break;				case thisX == 4 && thisY == 3:					chosenNavigationEvent = new NavigationEvent ( NavigationEvent.SETENDINGSCORE );					break;				case thisX == 4 && thisY == 4:					MovieClip(this.parent).playerServesFirst = false;					break;				case thisX == 4 && thisY == 5:					MovieClip(this.parent).playerServesFirst = true;					break;				case thisX == 4 && thisY == 6:					MovieClip(this.parent).soundToggle = !MovieClip(this.parent).soundToggle;					break;				case thisX == 5 && thisY == 0:					chosenNavigationEvent = new NavigationEvent ( NavigationEvent.INSTRUCTIONS );					break;				}						if ( chosenNavigationEvent != null )			{				dispatchEvent( chosenNavigationEvent );			}			else			{				updateCheckmarks();			}		}				public function onOutDropItem( e:MouseEvent ):void		{			e.currentTarget.resetThis();		}				public function updateCheckmarks():void		{			// Goes through all the Main class variables that affect check marks, and updates them. Called			// when a variable is changed, and when the top menu is constructed.						switch( MovieClip(this.parent).playerSize )				{				case 1:					dropMenu2.menuitemContainer[0].checkBitmap.visible = true;					dropMenu2.menuitemContainer[1].checkBitmap.visible = false;					dropMenu2.menuitemContainer[2].checkBitmap.visible = false;					break;				case 2:					dropMenu2.menuitemContainer[0].checkBitmap.visible = false;					dropMenu2.menuitemContainer[1].checkBitmap.visible = true;					dropMenu2.menuitemContainer[2].checkBitmap.visible = false;					break;				case 3:					dropMenu2.menuitemContainer[0].checkBitmap.visible = false;					dropMenu2.menuitemContainer[1].checkBitmap.visible = false;					dropMenu2.menuitemContainer[2].checkBitmap.visible = true;					break;				}						switch( MovieClip(this.parent).enemySize )				{				case 1:					dropMenu2.menuitemContainer[3].checkBitmap.visible = true;					dropMenu2.menuitemContainer[4].checkBitmap.visible = false;					dropMenu2.menuitemContainer[5].checkBitmap.visible = false;					break;				case 2:					dropMenu2.menuitemContainer[3].checkBitmap.visible = false;					dropMenu2.menuitemContainer[4].checkBitmap.visible = true;					dropMenu2.menuitemContainer[5].checkBitmap.visible = false;					break;				case 3:					dropMenu2.menuitemContainer[3].checkBitmap.visible = false;					dropMenu2.menuitemContainer[4].checkBitmap.visible = false;					dropMenu2.menuitemContainer[5].checkBitmap.visible = true;					break;				}						switch( MovieClip(this.parent).ballSize )				{				case 1:					dropMenu3.menuitemContainer[0].checkBitmap.visible = true;					dropMenu3.menuitemContainer[1].checkBitmap.visible = false;					dropMenu3.menuitemContainer[2].checkBitmap.visible = false;					break;				case 2:					dropMenu3.menuitemContainer[0].checkBitmap.visible = false;					dropMenu3.menuitemContainer[1].checkBitmap.visible = true;					dropMenu3.menuitemContainer[2].checkBitmap.visible = false;					break;				case 3:					dropMenu3.menuitemContainer[0].checkBitmap.visible = false;					dropMenu3.menuitemContainer[1].checkBitmap.visible = false;					dropMenu3.menuitemContainer[2].checkBitmap.visible = true;					break;				}							switch( Main.getBallSpeed() )				{				case 1:					dropMenu3.menuitemContainer[3].checkBitmap.visible = true;					dropMenu3.menuitemContainer[4].checkBitmap.visible = false;					dropMenu3.menuitemContainer[5].checkBitmap.visible = false;					break;				case 2:					dropMenu3.menuitemContainer[3].checkBitmap.visible = false;					dropMenu3.menuitemContainer[4].checkBitmap.visible = true;					dropMenu3.menuitemContainer[5].checkBitmap.visible = false;					break;				case 3:					dropMenu3.menuitemContainer[3].checkBitmap.visible = false;					dropMenu3.menuitemContainer[4].checkBitmap.visible = false;					dropMenu3.menuitemContainer[5].checkBitmap.visible = true;					break;				}						switch( Main.getDifficulty() )				{				case 1:					dropMenu4.menuitemContainer[0].checkBitmap.visible = true;					dropMenu4.menuitemContainer[1].checkBitmap.visible = false;					dropMenu4.menuitemContainer[2].checkBitmap.visible = false;					break;				case 2:					dropMenu4.menuitemContainer[0].checkBitmap.visible = false;					dropMenu4.menuitemContainer[1].checkBitmap.visible = true;					dropMenu4.menuitemContainer[2].checkBitmap.visible = false;					break;				case 3:					dropMenu4.menuitemContainer[0].checkBitmap.visible = false;					dropMenu4.menuitemContainer[1].checkBitmap.visible = false;					dropMenu4.menuitemContainer[2].checkBitmap.visible = true;					break;				}						switch( MovieClip(this.parent).playerServesFirst )				{				case true:					dropMenu4.menuitemContainer[4].checkBitmap.visible = false;					dropMenu4.menuitemContainer[5].checkBitmap.visible = true;					break;				case false:					dropMenu4.menuitemContainer[4].checkBitmap.visible = true;					dropMenu4.menuitemContainer[5].checkBitmap.visible = false;					break;				}						switch( MovieClip(this.parent).soundToggle )				{				case true:					dropMenu4.menuitemContainer[6].checkBitmap.visible = true;					break;				case false:					dropMenu4.menuitemContainer[6].checkBitmap.visible = false;					break;				}		}	}}