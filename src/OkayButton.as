package{	import flash.display.Sprite;	import flash.events.Event;	import flash.events.MouseEvent;	import flash.events.KeyboardEvent;	import flash.utils.Timer;	import flash.events.TimerEvent;	import flash.display.Bitmap;		public class OkayButton extends Sprite	{		// In the original OS that GNOP! ran in, holding down return for about half a second counted as a full down-up click of the button,		// and would close dialogs even if you continued to hold the button. However, I couldn't find a way to implement the timer without		// breaking things (namely when SetEndScore popped up ScoreWarning) so I'm leaving that out for now.  The code is in place		// but commented out.				// Also, I should note that an error sound plays when ScoreWarning pops, but I don't know if that sound is trademarked or anything,		// so it's not included. It's an OS sound, not a GNOP! sound.				public var returnTimer:Timer;				[Embed(source = "data/ok.png")] public var OkayBitmap:Class;		public var okayBitmap:Bitmap = new OkayBitmap();				[Embed(source = "data/ok_fg.png")] public var OkayFGBitmap:Class;		public var okayFGBitmap:Bitmap = new OkayFGBitmap();				public function OkayButton()		{			if ( stage )			{				onAddtoStage();			}			else			{				addEventListener( Event.ADDED_TO_STAGE, onAddtoStage, false, 0, true );			}		}				public function onAddtoStage( e:Event = null ):void		{			removeEventListener( Event.ADDED_TO_STAGE, onAddtoStage );						addChild( okayBitmap );						okayFGBitmap.x = 5;			okayFGBitmap.y = 5;			okayFGBitmap.visible = false;			addChild( okayFGBitmap );						addEventListener( MouseEvent.MOUSE_DOWN, onDownOkay, false, 0, true );						// I'm disabling the return key functionality for now. It's pretty buggy, especially when ScoreWarning is open.			// Namely, it throws a lot of null values for stage, even when it's clearly on the stage. No idea why.						//stage.addEventListener( KeyboardEvent.KEY_DOWN, onKeyDownPress );		}				public function onKeyDownPress( keyboardEvent:KeyboardEvent ):void		{			if ( keyboardEvent.charCode == 13 )			{				stage.removeEventListener( KeyboardEvent.KEY_DOWN, onKeyDownPress );								okayFGBitmap.visible = true;								stage.addEventListener( KeyboardEvent.KEY_UP, onKeyUpPress, false, 0, true );								// Timer code; un-comment this and the two killTimer statements to enable the timer.				//returnTimer = new Timer( 500, 1 );				//returnTimer.addEventListener( TimerEvent.TIMER_COMPLETE, onReturnTimerComplete, false, 0, true );				//returnTimer.start();			}		}				public function timerReset():void		{			returnTimer.reset();		}				public function onKeyUpPress( k:KeyboardEvent ):void		{			if ( k.charCode == 13 )			{				stage.removeEventListener( KeyboardEvent.KEY_UP, onKeyUpPress );								//killTimer();  // This prevents the timer from completing after the pop-up is closed, which throws an error. Not game-breaking though.								sendAndReset();			}		}				public function killTimer():void		{			if ( returnTimer )			{				if ( returnTimer.running )				{					returnTimer.stop();				}								returnTimer = null;			}		}				public function onReturnTimerComplete( t:TimerEvent ):void		{			//killTimer();						stage.removeEventListener( KeyboardEvent.KEY_UP, onKeyUpPress );						sendAndReset();		}				public function onDownOkay( mouseEvent:MouseEvent ):void		{			removeEventListener( MouseEvent.MOUSE_DOWN, onDownOkay );			removeEventListener( MouseEvent.ROLL_OVER, onDownOkay );			okayFGBitmap.visible = true;						addEventListener( MouseEvent.MOUSE_UP, onUpOkay, false, 0, true );			addEventListener( MouseEvent.ROLL_OUT, onOutOkay, false, 0, true );		}				public function onUpOkay( mouseEvent:MouseEvent ):void		{			stage.removeEventListener( MouseEvent.MOUSE_UP, onOkayStageUp );						removeEventListener( MouseEvent.MOUSE_UP, onUpOkay );			removeEventListener( MouseEvent.ROLL_OUT, onOutOkay );						sendAndReset();		}				public function onOutOkay( mouseEvent:MouseEvent):void		{			removeEventListener( MouseEvent.ROLL_OUT, onOutOkay );			okayFGBitmap.visible = false;						stage.addEventListener( MouseEvent.MOUSE_UP, onOkayStageUp, false, 0, true );			addEventListener( MouseEvent.ROLL_OVER, onDownOkay, false, 0, true );		}				public function onOkayStageUp( mouseEvent:MouseEvent):void		{				if ( stage != null )			{				stage.removeEventListener( MouseEvent.MOUSE_UP, onOkayStageUp );				removeEventListener( MouseEvent.ROLL_OVER, onDownOkay );				addEventListener( MouseEvent.MOUSE_DOWN, onDownOkay, false, 0, true );			}		}				public function sendAndReset():void		{			okayFGBitmap.visible = false;			dispatchEvent( new Event( Event.COMPLETE ) );			addEventListener( MouseEvent.MOUSE_DOWN, onDownOkay, false, 0, true );						// stage.addEventListener( KeyboardEvent.KEY_DOWN, onKeyDownPress );		}	}}