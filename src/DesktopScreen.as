package{	import flash.display.BitmapData;	import flash.display.MovieClip;	import flash.events.TimerEvent;	import flash.ui.Mouse;	import flash.events.Event;	import flash.events.MouseEvent;	import flash.geom.ColorTransform;	import flash.utils.getTimer;	import flash.display.Sprite;	import flash.display.Bitmap;	import flash.utils.Timer;		public class DesktopScreen extends MovieClip	{		[Embed(source = "data/icon.png")] private var GnopIcon:Class;		private var gnopIcon:Bitmap = new GnopIcon();		private var gnopIconSprite:Sprite = new Sprite();				private var invisibleBG:Sprite;				[Embed(source = "data/septagon.png")] public var FakeSeptagon:Class;		private var fakeSeptagon:Bitmap = new FakeSeptagon();		private var fakeSeptagonSprite:Sprite = new Sprite();				private var isInverted:Boolean;		private var downTime:int;		private var upTime:int;		private var firstUpTime:int;				private var xDiff:Number;		private var yDiff:Number;				private var dragTimer:Timer;				// The desktop screen is the first thing the user sees. It emulates (very roughly) a desktop screen that may have been seen		// before loading the original GNOP!.				public function DesktopScreen()		{			if ( stage )			{				onAddtoStage();			}			else			{				addEventListener( Event.ADDED_TO_STAGE, onAddtoStage, false, 0, true );			}		}				public function onAddtoStage( e:Event = null ):void		{			removeEventListener( Event.ADDED_TO_STAGE, onAddtoStage );						Mouse.show();						// The invisible background (a big red square) is used as a proxy for clicking off the GNOP! icon instead of the stage.			// If we checked a stage click event for clicking off the icon, it'd pop for clicking on the icon as well.			// The big red square is set to be invisible (alpha = 0) for obvious reasons.						invisibleBG = new Sprite();			invisibleBG.graphics.beginFill( 0xFF0000 );			invisibleBG.graphics.drawRect( 0, 0, 640, 480 );			invisibleBG.graphics.endFill();			invisibleBG.x = 0;			invisibleBG.y = 0;			invisibleBG.alpha = 0;			addChild( invisibleBG );						// Add the centered GNOP! "desktop" icon.						gnopIconSprite.addChild( new Bitmap( gnopIcon.bitmapData.clone(), "auto", false ) );			gnopIconSprite.x = ( stage.stageWidth / 2 ) - Math.round( gnopIconSprite.width / 2 );			gnopIconSprite.y = ( stage.stageHeight / 2 ) - Math.round( gnopIconSprite.height / 2 );			addChild( gnopIconSprite );						// Add the fake (not clickable) upper-left septagon logo.						fakeSeptagonSprite.addChild( new Bitmap( fakeSeptagon.bitmapData.clone(), "auto", false ) );			fakeSeptagonSprite.x = 17;			fakeSeptagonSprite.y = 3;			addChild( fakeSeptagonSprite );						// uints default to zero, and we later use firstUpTime to determine the time between two clicks.  If the user clicks the icon			// within one second of loading the program, then upTime - firstUpTime is less than 1000, and it registers as a double-click.			// To prevent this, we set firstUpTime to an arbitrary negative value greater than negative one second.						firstUpTime = -2000;						// Nothing really happens on the desktop until the user clicks the icon. At that point, they can drag, or do a double-click.						gnopIconSprite.addEventListener( MouseEvent.MOUSE_DOWN, onDrag, false, 0, true );						// If we created an XML file, an optional method exists for saving the XML file externally.			// I didn't want this to be something the user might do on accident, so it's a bit cumbersome.			// This process really only exists in the case that a user has broken their XML file and wants a new local copy.						fakeSeptagonSprite.addEventListener( MouseEvent.MOUSE_DOWN, onDownSeptagon, false, 0, true );		}				public function onDrag( mouseEvent:MouseEvent ):void		{			if ( !isInverted )			{				invertIcon();			}						// If the icon was clicked, then clearly the mouse is on stage. Also log time of first mouse down action.						downTime = getTimer(); // Log time of this click's beginning.						xDiff = mouseX - gnopIconSprite.x;			yDiff = mouseY - gnopIconSprite.y;						dragTimer = new Timer( 24, 0 );			dragTimer.addEventListener(TimerEvent.TIMER, updateIcon, false, 0, true );			dragTimer.start();						stage.addEventListener( MouseEvent.MOUSE_UP, onDrop, false, 0, true );		}				public function updateIcon ( t:TimerEvent ):void		{			var tempX:Number = mouseX - xDiff;			var tempY:Number = mouseY - yDiff;						if ( tempX < 0 )			{				tempX = 0;			}						if ( tempX > 640 - gnopIconSprite.width )			{				tempX = 640 - gnopIconSprite.width;			}						if ( tempY < 20 )			{				tempY = 20;			}						if ( tempY > 480 - gnopIconSprite.height )			{				tempY = 480 - gnopIconSprite.height;			}						gnopIconSprite.x = tempX;			gnopIconSprite.y = tempY;		}				public function onDrop( m:MouseEvent ):void		{			dragTimer.stop();						upTime = getTimer(); // Log time of this click's completion.						stage.removeEventListener( MouseEvent.MOUSE_UP, onDrop );						// If the user has clicked twice in rapid succession, so if the current "drag" was really a click, and it occurs			// in close proximity to a previous click, then we register it as a double click and load the splash screen by			// sending a "complete" event to the main class.						if ( ( upTime - downTime ) < 250 )			{				if ( ( upTime - firstUpTime ) < 1000 )				{					dispatchEvent( new Event( Event.COMPLETE ) );				}				else				{					firstUpTime = upTime;				}			}		}				public function onUnClick( mouseEvent:MouseEvent ):void		{			// If the user clicks the background, un-highlight the icon.			// We also want to remove any chance of a subsequent click on the icon being registered as a double click (in the			// rare scenario where a user clicks on the icon, then the background, then the icon again within a second) so we			// arbitrarily set the time of first click to before the program was first loaded.						firstUpTime = -2000;						invertIcon();		}				public function invertIcon():void		{			// Performs a simple inversion of the icon.						if ( isInverted)			{				gnopIconSprite.transform.colorTransform = new ColorTransform( 1, 1, 1, 1, 0, 0, 0 );				isInverted = false;								invisibleBG.removeEventListener( MouseEvent.MOUSE_DOWN, onUnClick );			}			else			{				gnopIconSprite.transform.colorTransform = new ColorTransform( -1, -1, -1, 1, 255, 255, 255 );				isInverted = true;								invisibleBG.addEventListener( MouseEvent.MOUSE_DOWN, onUnClick, false, 0, true );			}		}				public function onDownSeptagon( m:MouseEvent ):void		{			fakeSeptagonSprite.removeEventListener( MouseEvent.MOUSE_DOWN, onDownSeptagon );			fakeSeptagonSprite.addEventListener( MouseEvent.MOUSE_UP, onUpBGorSept, false, 0, true );			gnopIconSprite.addEventListener( MouseEvent.MOUSE_UP, onUpIcon, false, 0, true );			invisibleBG.addEventListener( MouseEvent.MOUSE_UP, onUpBGorSept, false, 0, true );		}				public function onUpBGorSept( m:MouseEvent ):void		{			gnopIconSprite.removeEventListener( MouseEvent.MOUSE_UP, onUpIcon );			invisibleBG.removeEventListener( MouseEvent.MOUSE_UP, onUpBGorSept );			fakeSeptagonSprite.removeEventListener( MouseEvent.MOUSE_UP, onUpBGorSept );		}				public function onUpIcon( m:MouseEvent ):void		{			gnopIconSprite.removeEventListener( MouseEvent.MOUSE_UP, onUpIcon );			invisibleBG.removeEventListener( MouseEvent.MOUSE_UP, onUpBGorSept );			fakeSeptagonSprite.removeEventListener( MouseEvent.MOUSE_UP, onUpBGorSept );			dispatchEvent( new NavigationEvent( NavigationEvent.SAVE ) );		}	}}