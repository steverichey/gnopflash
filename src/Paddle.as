package{	import flash.display.Bitmap;	import flash.display.Sprite;	import flash.display.MovieClip;	import flash.utils.Timer;	import flash.events.TimerEvent;	import flash.events.Event;	import flash.geom.ColorTransform;		public class Paddle extends Sprite	{		private var paddleSprite:Sprite;		private var animateTimer:Timer;		private var paddleSize:uint;		public var isEnemy:Boolean;		private var paddleColor:uint;		private var paddleMultiplier:uint;		private var paddleWidth:uint;		private var timerCount:uint;		private var failTransform:ColorTransform;				[Embed(source = "data/fail01.png")] private var Fail_01:Class;		private var fail_01:Bitmap = new Fail_01;				[Embed(source = "data/fail02.png")] private var Fail_02:Class;		private var fail_02:Bitmap = new Fail_02;				public function Paddle( pddlSz:uint, sEnm:Boolean, pddlClr:uint = 0x000000, pddlMlt:uint = 14, pddlWdth:uint = 8 )		{			this.paddleSize = pddlSz;			this.isEnemy = sEnm;			this.paddleColor = pddlClr;			this.paddleMultiplier = pddlMlt;			this.paddleWidth = pddlWdth;						if ( stage )			{				onAddtoStage();			}			else			{				addEventListener( Event.ADDED_TO_STAGE, onAddtoStage, false, 0, true );			}		}				public function onAddtoStage( e:Event = null ):void		{			removeEventListener( Event.ADDED_TO_STAGE, onAddtoStage );						paddleSprite = new Sprite();						paddleSprite.graphics.beginFill( paddleColor );			paddleSprite.graphics.drawRect( 0, 0, paddleWidth, paddleSize * paddleMultiplier );			paddleSprite.graphics.endFill();						addChild( paddleSprite );		}				public function failAnimate():void		{			removeChild( paddleSprite );			fail_01.x = ( paddleSprite.width / 2 ) - ( fail_01.width / 2 );						if ( this.y + ( paddleSprite.height / 2 ) - ( fail_01.height / 2 ) < MovieClip( this.parent ).minY )			{				fail_01.y = 0;				this.y = MovieClip( this.parent ).minY;			}			else if ( this.y + ( paddleSprite.height / 2 ) - ( fail_01.height / 2 ) + fail_01.height > MovieClip( this.parent ).maxY - 5 )			{				fail_01.y = 0;				this.y = MovieClip( this.parent ).maxY - fail_01.height - 5;			}			else			{				fail_01.y = ( paddleSprite.height / 2 ) - ( fail_01.height / 2 );			}						failTransform = new ColorTransform();			failTransform.color = paddleColor;			fail_01.transform.colorTransform = failTransform;						addChild( fail_01 );						animateTimer = new Timer( 250, 3 );			animateTimer.addEventListener( TimerEvent.TIMER, nextAnimate, false, 0, true );			timerCount = 0;			animateTimer.start();		}				public function nextAnimate( t:TimerEvent ):void		{			if ( timerCount == 0 )			{				this.y = MovieClip( this.parent ).maxY - fail_02.height - 5;				removeChild( fail_01 );								fail_02.x = ( paddleSprite.width / 2 ) - ( fail_02.width / 2 );								fail_02.transform.colorTransform = failTransform;								addChild( fail_02 );			}			else if ( timerCount == 2 )			{				animateTimer.removeEventListener( TimerEvent.TIMER, nextAnimate );				animateTimer = null;								removeChild( fail_02 );								// Have to bump up the calculated position by half the paddle height because the paddle is currently				// not on the stage, so the PlayScreen function incorrectly calculates it as too low.								if ( this == MovieClip( this.parent).enemyPaddle )				{					this.y = MovieClip( this.parent).calculatePaddlePosition( this, "stationary" ) - ( paddleSprite.height / 2 );				}				else				{					this.y = MovieClip( this.parent).calculatePaddlePosition( this, "mouse" ) - ( paddleSprite.height / 2 );										if ( this.y < MovieClip( this.parent).minY )					{						this.y = MovieClip( this.parent).minY;					}										if ( this.y > MovieClip( this.parent ).maxY - paddleSprite.height - MovieClip( this.parent ).bottomVerticalPadding )					{						this.y = MovieClip( this.parent ).maxY - paddleSprite.height - MovieClip( this.parent ).bottomVerticalPadding;					}				}								addChild( paddleSprite );								dispatchEvent( new Event( Event.COMPLETE ) );			}						timerCount++;		}	}}