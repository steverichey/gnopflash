package{	import flash.display.Bitmap;	import flash.display.BitmapData;	import flash.display.MovieClip;	import flash.ui.Mouse;	import flash.utils.Timer;	import flash.events.Event;	import flash.events.MouseEvent;	import flash.events.KeyboardEvent;	import flash.events.TimerEvent;	import flash.media.SoundChannel;	import flash.media.Sound;	import flash.utils.getTimer;	import XMLContainer;	import flash.text.TextField;	import flash.text.TextFormat;	import flash.text.GridFitType;	import flash.text.AntiAliasType;		public class PlayScreen extends MovieClip	{		public var playerPaddle:Paddle;		public var enemyPaddle:Paddle;		private var ball:Ball;		private var serveBall:Ball;		private var playerScore:Score;		private var enemyScore:Score;		private var displayScore:Score;		public var gameTimer:Timer;		public var minX:uint;		public var maxX:uint;		public var minY:uint;		public var maxY:uint;		private var playerServe:Boolean;		private var ballPossession:Boolean;		private var calculatedBallPosition:Vector.<uint>;		private var ballVelocityX:Number;		private var ballVelocityY:Number;		private var invisibleBG:Bitmap;		private var invisibleBGData:BitmapData;		private var ballX:Number;		private var ballY:Number;		private var previousBallX:Number;		private var previousBallY:Number;				private var whiteBox:Bitmap;		private var whiteBoxData:BitmapData;				private var leaveBitmap:Bitmap;		private var leaveBitmapData:BitmapData;		private var leaveTextField:TextField;				private var paddleUpperBoundsRatio:Number;		private var paddleLowerBoundsRatio:Number;		public var bottomVerticalPadding:uint;		private var topVerticalPadding:uint;				private var predictedPathArray:Array;		private var actualPathArray:Array;				// private var lastBounceTime:uint; // For debugging "ball speed".				// Set game constants based on XML and top menu selections.				private const BALL_SPEED:uint = XMLContainer.defaultXML.io.ballspeedmultiplier.@value;				// I recorded some GNOP! gameplay and played the footage back frame-by-frame to arrive at a		// constant horizontal ball speed of 10 pixels per frame. So, ball speed is constant, but		// tick frequency changes.				private const TICK_FREQUENCY:uint = XMLContainer.defaultXML.io.tickspeed.speed.@value[ Main.getBallSpeed() - 1 ];		private const ENEMY_MOVE_SPEED:uint = uint( XMLContainer.defaultXML.io.enemy.@speedfactor ) + Main.getDifficulty();				// Based on the same frame-by-frame analysis, I observed the following computer paddle speeds:		// 2 pixels per frame on Novice.		// 3 pixels per frame on Intermediate.		// 4 pixels per frame on Expert.		// So, for now the math is simply 1 + difficulty, with the latter being 1-3, and the former being XML configurable.				private const ENEMY_TYPE:String = XMLContainer.defaultXML.io.enemy.@type;		private const PLAYER_TYPE:String = XMLContainer.defaultXML.io.player.@type;		private const VELOCITY_RATIO:Number = XMLContainer.defaultXML.io.velocityratio.@value;		private const BOUNCE_DAMPENER:Number = XMLContainer.defaultXML.io.bounce.@dampener;				private const SHOW_PATH:Boolean = Boolean( uint( XMLContainer.defaultXML.io.ai.@showpath ) );		private const LEAVE_PAUSE:Boolean = Boolean( uint( XMLContainer.defaultXML.io.mouseleave.@notification ) );				[Embed(source = "data/GNOP_Miss.mp3")] private var Miss:Class;		private var miss:Sound = new Miss();				[Embed(source = "data/GNOP_Bounce.mp3")] private var BallBounce:Class;		private var ballBounce:Sound = new BallBounce();				[Embed(source = "data/GNOP_MatchPoint.mp3")] private var MatchPoint:Class;		private var matchPoint:Sound = new MatchPoint();				[Embed(source = "data/play_board.png")] private var PlayBoard:Class;		private var playBoard:Bitmap = new PlayBoard();				[Embed(source = "data/play_corner.png")] private var PlayCorner:Class;		private var playCorner1:Bitmap = new PlayCorner();		private var playCorner2:Bitmap = new PlayCorner();		private var playCorner3:Bitmap = new PlayCorner();		private var playCorner4:Bitmap = new PlayCorner();				[Embed(source = "data/play_border_1px.png")] private var PlayBorder:Class;		private var playBorder1:Bitmap = new PlayBorder();		private var playBorder2:Bitmap = new PlayBorder();		private var playBorder3:Bitmap = new PlayBorder();		private var playBorder4:Bitmap = new PlayBorder();				private var sfxSoundChannel:SoundChannel;				// This code is all based on my perception of how the game works from extensive playtesting. Alexander Seropian said on Twitter		// that he had no idea where to look for the code; Bungie has been mum on the subject.  Therefore, I assumed the original code		// to be gone. However, if found, that code could be integrated here to achieve improved simulation accuracy.  Nonetheless,  I		// found that this remake plays much the same as the original.  An alternative to "finding" the code would be to decompile the		// original binary file, but I don't have the resources to do that.				public function PlayScreen()		{			if ( stage )			{				onAddtoStage();			}			else			{				addEventListener( Event.ADDED_TO_STAGE, onAddtoStage, false, 0, true );			}		}				public function onAddtoStage( e:Event = null ):void		{			removeEventListener( Event.ADDED_TO_STAGE, onAddtoStage );						Mouse.hide();						// Add an invisible background bitmap; this prevents the scenario where a click to serve outside of the playable			// space would not register.						invisibleBGData = new BitmapData( stage.stageWidth, stage.stageHeight, false, 0xFF0000 );			invisibleBG = new Bitmap( invisibleBGData, "auto", false );			invisibleBG.alpha = 0;			addChild( invisibleBG );						// playX and playY are the upper-left corner values of the play screen. playY is bumped down by 10px			// to account for the top menu; this is per the original GNOP!						var playX:uint = ( stage.stageWidth / 2 ) - ( Math.round( uint( XMLContainer.defaultXML.display.play.@width ) / 2 ) );			var playY:uint = ( ( stage.stageHeight ) / 2 ) - ( Math.round( uint( XMLContainer.defaultXML.display.play.@height ) / 2 ) ) + 10;						// Draw the playable space. It's a bit complicated, but as part of bug-testing I decided to implement custom			// space width and height via XML, so this "procedurally" draws the space.						whiteBoxData = new BitmapData( uint( XMLContainer.defaultXML.display.play.@width ) - 10, uint( XMLContainer.defaultXML.display.play.@height ) - 10, false, uint( XMLContainer.defaultXML.display.play.@color ) );			whiteBox = new Bitmap( whiteBoxData, "auto", false );			whiteBox.x = playX + playCorner1.width;			whiteBox.y = playY + playCorner1.height;			addChild( whiteBox );						playCorner1.x = playX;			playCorner1.y = playY;			addChild( playCorner1 );						playCorner2.rotation = 90;			playCorner2.x = playX + uint( XMLContainer.defaultXML.display.play.@width );			playCorner2.y = playY;			addChild( playCorner2 );						playCorner3.rotation = -90;			playCorner3.x = playX;			playCorner3.y = playY + uint( XMLContainer.defaultXML.display.play.@height );			addChild( playCorner3 );						playCorner4.rotation = 180;			playCorner4.x = playX + uint( XMLContainer.defaultXML.display.play.@width );			playCorner4.y = playY + uint( XMLContainer.defaultXML.display.play.@height );			addChild( playCorner4 );						playBorder1.x = playX + playCorner1.width;			playBorder1.y = playY;			playBorder1.width = whiteBox.width;			addChild( playBorder1 );						playBorder2.x = playX + whiteBox.width + playCorner1.width + playCorner2.width;			playBorder2.y = playY + playCorner1.height;			playBorder2.width = whiteBox.height;			playBorder2.rotation = 90;			addChild( playBorder2 );						playBorder3.x = playX;			playBorder3.y = playY + playCorner1.height + whiteBox.height;			playBorder3.width = whiteBox.height;			playBorder3.rotation = -90;			addChild( playBorder3 );						playBorder4.x = playX + whiteBox.width + playCorner1.width;			playBorder4.y = playY + playCorner1.height + playCorner2.height + whiteBox.height;			playBorder4.width = whiteBox.width;			playBorder4.rotation = 180;			addChild( playBorder4 );						playBoard.x = ( stage.width / 2 ) - ( playBoard.width / 2 );			playBoard.y = playY + 9;			addChild( playBoard );						playerServe = MovieClip(this.parent).playerServesFirst;						if ( SHOW_PATH ) // Displays path AI expects ball to take			{				predictedPathArray = new Array();				actualPathArray = new Array();			}						// Set boundaries that do not require paddle or ball height or width						minY = playBoard.y + playBoard.height;			maxY = whiteBox.y + whiteBox.height;						// Create paddles and ball.						spawnPlayer();			spawnEnemy();			spawnBall();						// Instantiate vector that stores calculated ball positions for later use.						calculatedBallPosition = new Vector.<uint>( 2 );						if ( PLAYER_TYPE == "ai" )  // Allows the game to play itself, for debugging.			{				ballPossession = false;				calculateBallPosition( playerServe );				calculatedBallPosition[1] = Math.round ( calculatePaddlePosition( playerPaddle, "stationary" ) );			}			else			{				ballPossession = true;			}						// Set remaining boundaries for paddles and ball.						minX = enemyPaddle.x + enemyPaddle.width;			maxX = playerPaddle.x;						//calculateBallPosition( enemyPaddle );						// Get upper and lower bounds ratios for AI-controlled paddles; in other words, the ratio of the paddle's height			// at which the paddle will no longer be concerned with heading to the ball's calculated position.						paddleUpperBoundsRatio = Number( XMLContainer.defaultXML.io.enemy.@upperratio );			paddleLowerBoundsRatio = Number( XMLContainer.defaultXML.io.enemy.@lowerratio );						bottomVerticalPadding = uint( XMLContainer.defaultXML.display.play.@ybottompadding );			topVerticalPadding = uint( XMLContainer.defaultXML.display.play.@ytoppadding );						// Create score fields (in the upper "board") and display the score to win.						playerScore = new Score();			playerScore.x = playBoard.x + 468;			playerScore.y = playBoard.y + 6;			addChild( playerScore );						enemyScore = new Score();			enemyScore.x = playBoard.x + 8;			enemyScore.y = playBoard.y + 6;			addChild( enemyScore );						displayScore = new Score();			displayScore.x = playBoard.x + 308;			displayScore.y = playBoard.y + 7;			addChild( displayScore );						displayScore.updateScore( MovieClip(this.parent).scoreToWin );						// Need a mouse click listener for serving and a key press listener for pausing (P key) and quitting (Q key).						addEventListener( MouseEvent.MOUSE_DOWN, onClick, false, 0, true );			stage.addEventListener( KeyboardEvent.KEY_DOWN, onKeyPress );						/*			 * Set up ball speed values.			 * In the original GNOP!, some cross-screen times (in seconds) are:				 * Slow:   2.508, 2.554, 2.470, 2.589				 * Normal: 1.283, 1.363, 1.384, 1.454, 1.495				 * Fast:   0.600, 0.651, 0.660			 * Times measured by playing GNOP! while recording sound, and measuring the time between bounce sounds,			 * while the ball travelled straight across the screen.			 * The times are not exact, which makes me think that Seropian's tick function was not very precise.			 * This is okay, because the default Flash timer is not very precise either.			 * Also, while I wasn't sure at first, it seems as though adjusting the ball speed actually changes the tick			 * frequency. Not only does the ball move faster at higher speeds, so does the enemy paddle. So, upping the			 * ball speed makes the game more difficult in two ways!			*/						gameTimer = new Timer( TICK_FREQUENCY );			gameTimer.addEventListener( TimerEvent.TIMER, onTick );			gameTimer.start();						if ( LEAVE_PAUSE )			{				stage.addEventListener( Event.MOUSE_LEAVE, onLeaveScreen, false, 0, true );			}		}				public function onKeyPress( k:KeyboardEvent ):void		{			if ( gameTimer != null ) // Prevent errors when trying to manipulate timer later			{				if ( k.keyCode == 81 ) // Press "q" or "Q"				{					if ( gameTimer.running ) // In the original, couldn't quit while paused.					{						gameTimer.stop();						gameTimer = null;												dispatchEvent( new NavigationEvent( NavigationEvent.QUITGAME ) );					}				}				else if ( k.keyCode == 80 ) // Press "p" or "P"				{					if ( !ballPossession ) // In the original, couldn't pause while anyone is "holding" ball with paddle.					{						if ( gameTimer.running )						{							gameTimer.stop();						}						else						{							gameTimer.start();						}					}				}			}		}				public function spawnPlayer():void		{			playerPaddle = new Paddle( MovieClip(this.parent).playerSize, false, XMLContainer.defaultXML.defaults.player.@color, XMLContainer.defaultXML.defaults.player.@multiplier, XMLContainer.defaultXML.defaults.player.@width );			playerPaddle.x = whiteBox.x + whiteBox.width - uint( XMLContainer.defaultXML.display.play.@xpadding ) - uint( XMLContainer.defaultXML.defaults.player.@width );						// Have to compensate for the fact that the paddle isn't drawn yet						playerPaddle.y = calculatePaddlePosition( playerPaddle, "mouse" );/* - ( XMLContainer.defaultXML.defaults.player.@multiplier * MovieClip(this.parent).playerSize / 2 );*/			addChild( playerPaddle );		}				public function spawnEnemy():void		{			enemyPaddle = new Paddle( MovieClip(this.parent).enemySize, true, XMLContainer.defaultXML.defaults.enemy.@color, XMLContainer.defaultXML.defaults.enemy.@multiplier, XMLContainer.defaultXML.defaults.enemy.@width );			enemyPaddle.x = whiteBox.x + uint( XMLContainer.defaultXML.display.play.@xpadding );						// Have to compensate for the fact that the paddle isn't drawn yet						enemyPaddle.y = calculatePaddlePosition( enemyPaddle, "stationary" )  - ( XMLContainer.defaultXML.defaults.player.@multiplier * MovieClip( this.parent ).enemySize / 2 );			addChild( enemyPaddle );		}				public function spawnBall():void		{			ball = new Ball( MovieClip(this.parent).ballSize, uint( XMLContainer.defaultXML.defaults.ball.@color ) );						// Don't want the ball to be visible yet, still need to set x and y values, but we'll need height and width of			// the ball soon.						ball.visible = false;			addChild( ball );						// We respawn the ball indicating last serve on the "board" every time the playable ball is respawned.						if ( serveBall != null )			{				removeChild( serveBall );				serveBall = null;			}						serveBall = new Ball( 4, uint( XMLContainer.defaultXML.defaults.ball.@color ) );						var serveXOffset:uint; // Where to put the serve ball; essentially, the player's or enemy's side of the board.						if ( playerServe )			{				ball.x = playerPaddle.x - ball.width - 1;				ball.y = playerPaddle.y + playerPaddle.height / 2 - ball.height / 2;				ballVelocityX = -1;								serveXOffset = 450;			}			else			{				ball.x = enemyPaddle.x + enemyPaddle.width + 1;				ball.y = enemyPaddle.y + enemyPaddle.height / 2 - ball.height / 2;				ballVelocityX = 1;								serveXOffset = 42;			}						ballX = ball.x;			ballY = ball.y;						serveBall.x = playBoard.x + serveXOffset;			serveBall.y = playBoard.y + 10;			addChild( serveBall );						if ( XMLContainer.defaultXML.io.serve.@type == "random" )			{				ballVelocityY = (Math.random() * 2) - 1;			}			else			{				ballVelocityY = 0;			}						ball.visible = true;		}				public function onClick( m:MouseEvent ):void		{			if ( ballPossession && gameTimer.running )			{				ballPossession = false;								calculateBallPosition( true );			}		}				public function onTick( t:TimerEvent ):void		{			movePaddles();						if ( ballPossession )			{				// If someone is serving, the ball should be directly in the middle of the paddle.								if ( playerServe )				{					ball.y = playerPaddle.y + playerPaddle.height / 2 - ball.height / 2;				}				else				{					ball.y = enemyPaddle.y + enemyPaddle.height / 2 - ball.height / 2;				}			}			else			{				checkWallBounce();							checkPaddleBounce();			}		}				public function movePaddles():void		{			// Move the paddles. Various configurations can be enabled via the XML file for debugging.						playerPaddle.y = calculatePaddlePosition( playerPaddle, PLAYER_TYPE );						if ( ballPossession )			{				enemyPaddle.y = calculatePaddlePosition( enemyPaddle, "stationary" );			}			else			{				enemyPaddle.y = calculatePaddlePosition( enemyPaddle, ENEMY_TYPE );			}		}				public function checkWallBounce():void		{			var tempArray:Array = getNextBallYPosition( ball.y, ballVelocityY, false );			ball.y = tempArray[0];			ballVelocityY = tempArray[1];		}				public function checkPaddleBounce():void		{			// Establish potential new ball x position.						ballX = ball.x + ballVelocityX * BALL_SPEED;						if ( ballX < minX )			{				if( ball.y > enemyPaddle.y - ball.height && ball.y < enemyPaddle.y + enemyPaddle.height )				{					ball.x = minX;					ball.x = minX + ( minX - ballX );										paddleBounce( enemyPaddle );				}				else				{					scorePoint( enemyPaddle );				}			}			else if ( ballX > maxX - ball.width )			{				if( ball.y > playerPaddle.y - ball.height && ball.y < playerPaddle.y + playerPaddle.height )				{					ball.x = maxX - ball.width;					ball.x = ( maxX - ball.width ) - ( ballX - ( maxX - ball.width ) );										paddleBounce( playerPaddle );				}				else				{					scorePoint( playerPaddle );				}			}			else			{				ball.x = ballX;			}						if ( SHOW_PATH && ball != null )			{				var actualPosition:Bitmap = new Bitmap( new BitmapData( ball.width / 2, ball.height / 2, false, 0xFF0000 ) );				actualPosition.x = ball.x + ball.width / 4;				actualPosition.y = ball.y + ball.height / 4;				addChild( actualPosition );				actualPathArray.push( actualPosition );			}		} // End checkPaddleBounce				public function paddleBounce( thisPaddle:Object ):void		{			if ( MovieClip(this.parent).soundToggle )			{				sfxSoundChannel = ballBounce.play();			}						ballVelocityX = -ballVelocityX;						var fromCenter:Number = ( ball.y + ( ball.height / 2 ) ) - ( thisPaddle.y + ( thisPaddle.height / 2 ) );						// Convert difference between centers to percentage.						fromCenter = fromCenter / ( ball.height / 2 + thisPaddle.height / 2 );						// Compute the new ball Y speed, using the distance from center to determine how much the ball's angle			// should be influenced.						ballVelocityY = fromCenter * BOUNCE_DAMPENER + ( ( 1 - fromCenter ) * ballVelocityY );						calculateBallPosition( !thisPaddle.isEnemy );		} // End paddleBounce				public function scorePoint( thisPaddle:Object ):void		{			removeChild( ball );			ball = null;			gameTimer.stop();						if ( MovieClip(this.parent).soundToggle )			{				sfxSoundChannel = miss.play();			}						thisPaddle.failAnimate();			thisPaddle.addEventListener( Event.COMPLETE, onFailAnimationComplete  );		}				public function onFailAnimationComplete( e:Event ):void		{			// Points can only be scored on a serve.						if ( e.currentTarget == enemyPaddle )			{				if ( playerServe )				{					playerScore.updateScore( 1 );				}								playerServe = true;								if ( playerScore.scoreValue == MovieClip(this.parent).scoreToWin - 1 )				{					// Play the match point sound if the player just scored, and is about to serve again.										if ( MovieClip(this.parent).soundToggle )					{						sfxSoundChannel = matchPoint.play();					}				}				else if ( playerScore.scoreValue != 0 && playerScore.scoreValue == MovieClip(this.parent).scoreToWin )				{					// End the game if the player has reached the score to win										gameOver( true );				}			}						if ( e.currentTarget == playerPaddle )			{				if ( !playerServe )				{					enemyScore.updateScore( 1 );				}								playerServe = false;								if ( enemyScore.scoreValue == MovieClip(this.parent).scoreToWin - 1 )				{					// Play the match point sound if the enemy just scored, and is about to serve again.										if ( MovieClip(this.parent).soundToggle )					{						sfxSoundChannel = matchPoint.play();					}				}				else if ( enemyScore.scoreValue != 0 && enemyScore.scoreValue == MovieClip(this.parent).scoreToWin )				{					// End the game if the enemy has reached the score to win										gameOver( false );				}			}						if ( gameTimer != null )			{				if( PLAYER_TYPE != "ai" )				{					ballPossession = true;				}								spawnBall();								if( PLAYER_TYPE == "ai" )				{					calculateBallPosition( e.currentTarget.isEnemy );				}								// This is a rather simple way to prevent a MOUSE_LEAVE condition during fail animation 				// from breaking the mouse leave pause functionality.								if ( leaveTextField == null )				{					gameTimer.start();				}			}		}				public function calculatePaddlePosition( thisPaddle:Object, type:String = "stationary" ):Number		{			// "mouse" - paddle follows the mouse (normal for the player's paddle)			// "ai" - position is based on movement towards a calculated ball position (normal for enemy's paddle)			// "impossible" - paddle always follows the ball perfectly			// "stationary" - paddle set at "middle" of stage			// Note that the "middle" used for stationary is a bit low; this appears to be the calculation used in			// the original, and in any case will always put the paddle in the same position as in the original.						var paddlePosition:Number;						if ( type == "mouse" )			{				// The original game put the paddle at the top of the playable space when the mouse was at				// the bottom of the top menu, and then moved the paddle down at the same rate as the mouse				// until the mouse was quite a few pixels from the bottom of the playable space.  The simpler				// calculation here is used to minimize unintentionally leaving the Flash container, but is				// not strictly GNOP!-esque.								paddlePosition = mouseY;								if ( paddlePosition < minY + topVerticalPadding )				{					paddlePosition = minY + topVerticalPadding;				}								if ( paddlePosition > maxY - thisPaddle.height - bottomVerticalPadding )				{					paddlePosition = maxY - thisPaddle.height - bottomVerticalPadding;				}								if ( ballPossession && ball.x > ( stage.stageWidth / 2 ) && Main.getDifficulty() == 1 )				{					// If the player is holding the ball, and the difficulty is set to "Novice", the minimum					// paddle Y becomes minY + 30, and the maximum becomes maxY - 33 - paddle.height.  This					// is because the difficulty level just changes how fast the enemy moves, and if the player					// were to serve from beyond these boundaries the enemy would be unable to reach the ball in					// time.										if ( paddlePosition < minY + 30 )					{						paddlePosition = minY + 30;					}					else if ( paddlePosition > maxY - 33 - thisPaddle.height )					{						paddlePosition = maxY - 33 - thisPaddle.height;					}				}			}			else if ( type == "impossible" )			{				if ( !ballPossession )				{					paddlePosition = ball.y - thisPaddle.height / 2 + ball.height / 2;				}				else				{					paddlePosition = calculatePaddlePosition( thisPaddle, "stationary" );				}			}			else if ( type == "ai" )			{				var ballMiddle:Number;								if ( thisPaddle.isEnemy )				{					ballMiddle = calculatedBallPosition[0] + ( ball.height / 2 );				}				else				{					ballMiddle = calculatedBallPosition[1] + ( ball.height / 2 );				}								var paddleCenter:uint = Math.round( thisPaddle.y ) + Math.round( thisPaddle.height / 2 );								if ( ballMiddle > paddleCenter )				{					// Very specific paddleMaxY is based on extensive observation of the original game; paddle will					// not move lower than 5px from bottom when Normal size, or 4px from bottom when Large size.										var paddleMaxY:uint = maxY - thisPaddle.height - bottomVerticalPadding;										if ( thisPaddle.height > 28 )					{						paddleMaxY -= 1;					}					else					{						paddleMaxY -= 2;					}										// Even if player paddle is set to AI, uses same move speed as enemy										if ( thisPaddle.y + ENEMY_MOVE_SPEED < paddleMaxY )					{						paddlePosition = thisPaddle.y + ENEMY_MOVE_SPEED;					}					else					{						paddlePosition = paddleMaxY;					}				}				else if ( ballMiddle < paddleCenter )				{					// See previous comment, 1px from top for normal, 3px from top for large.										var paddleMinY:uint = minY + topVerticalPadding;										if ( thisPaddle.height > 28 )					{						paddleMinY += 3;					}					else					{						paddleMinY += 1;					}										if ( thisPaddle.y - ENEMY_MOVE_SPEED > paddleMinY )					{						paddlePosition = thisPaddle.y - ENEMY_MOVE_SPEED;					}					else					{						paddlePosition = paddleMinY;					}				}				else				{					paddlePosition = thisPaddle.y;				}			}			else // Defaults to stationary			{				paddlePosition = whiteBox.y + ( whiteBox.height / 2 ) + ( playBoard.height / 2 ) - ( thisPaddle.height / 2 );			}						return paddlePosition;		} // End calculatePaddlePosition				public function calculateBallPosition( isEnemyPaddle:Boolean ):void		{			var tempBallX:Number = ball.x;			var tempBallY:Number = ball.y;			var tempBallVelocityY:Number = ballVelocityY;						if ( SHOW_PATH && predictedPathArray.length > 0 )			{				clearPathArray( predictedPathArray );				clearPathArray( actualPathArray );			}						while ( tempBallX > minX && tempBallX < ( maxX - ball.width ) )			{				tempBallX += ballVelocityX * BALL_SPEED;								var tempArray:Array = getNextBallYPosition( tempBallY, tempBallVelocityY, true );				tempBallY = tempArray[0];				tempBallVelocityY = tempArray[1];								if ( SHOW_PATH )				{					var predictedPosition:Bitmap = new Bitmap( new BitmapData( ball.width / 2, ball.height / 2, false, 0x0000FF ) );					predictedPosition.x = tempBallX + ball.width / 4;					predictedPosition.y = tempBallY + ball.height / 4;					addChild( predictedPosition );					predictedPathArray.push( predictedPosition );				}			}						if ( isEnemyPaddle )			{				calculatedBallPosition[0] = Math.round( tempBallY );			}			else			{				calculatedBallPosition[1] = Math.round( tempBallY );			}					}				public function getNextBallYPosition( thisBallY:Number, thisBallVelocityY:Number, isSimulation:Boolean ):Array		{			var potentialTempBallY:Number = thisBallY + thisBallVelocityY * BALL_SPEED * VELOCITY_RATIO;						if ( potentialTempBallY <= minY  )			{				if ( MovieClip(this.parent).soundToggle && !isSimulation )				{					sfxSoundChannel = ballBounce.play();				}								thisBallY = minY + ( minY - potentialTempBallY );				thisBallVelocityY = -thisBallVelocityY;			}			else if ( potentialTempBallY >= maxY - ball.height )			{				if ( MovieClip(this.parent).soundToggle && !isSimulation )				{					sfxSoundChannel = ballBounce.play();				}								thisBallY = ( maxY - ball.height ) - ( potentialTempBallY - ( maxY - ball.height ) );				thisBallVelocityY = -thisBallVelocityY;			}			else			{				thisBallY = potentialTempBallY;			}						return [ thisBallY, thisBallVelocityY ];		}				public function gameOver( playerWon:Boolean ):void		{			stage.removeEventListener( Event.MOUSE_LEAVE, onLeaveScreen );						gameTimer.stop();			gameTimer = null;						if ( playerWon )			{				dispatchEvent( new NavigationEvent( NavigationEvent.WIN ) );			}			else			{				dispatchEvent( new NavigationEvent( NavigationEvent.LOSE ) );			}		}				public function onLeaveScreen( e:Event ):void		{			if ( gameTimer != null )			{				if ( gameTimer.running )				{					gameTimer.stop();				}			}						if ( stage )			{				stage.removeEventListener( Event.MOUSE_LEAVE, onLeaveScreen ); // Occasionally throws an error								leaveBitmapData = new BitmapData( stage.stageWidth, stage.stageHeight, false, 0x000000 );				leaveBitmap = new Bitmap( leaveBitmapData );				leaveBitmap.alpha = 0.50;				addChild( leaveBitmap );								leaveTextField = new TextField();				leaveTextField.embedFonts = true;				leaveTextField.defaultTextFormat = new TextFormat( "chicago", 12, 0xFFFFFF, null, null, null, null, null, "center" );				leaveTextField.gridFitType = GridFitType.PIXEL;				leaveTextField.antiAliasType = AntiAliasType.ADVANCED;				leaveTextField.thickness = 0;				leaveTextField.sharpness = 0;				leaveTextField.text = "Paused.\nPlease click the screen to continue.";				leaveTextField.width = 250;				leaveTextField.height = 50;				leaveTextField.x = Math.round( stage.stageWidth / 2 - leaveTextField.width / 2 );				leaveTextField.y = Math.round( stage.stageHeight / 2 - leaveTextField.height / 2 );				leaveTextField.selectable = false;				addChild( leaveTextField );								stage.addEventListener( MouseEvent.MOUSE_DOWN, onClickLeaveNotice, false, 0, true );			}		}				public function onClickLeaveNotice( m:MouseEvent ):void		{			// Have to check for stage and non-null values because it's possible that the mouse left the stage while transitioning			// to the game over (splash) screen, in which case all of this stuff is null.						if ( stage != null )			{				stage.removeEventListener( MouseEvent.MOUSE_DOWN, onClickLeaveNotice );				stage.addEventListener( Event.MOUSE_LEAVE, onLeaveScreen, false, 0, true );			}						if ( leaveBitmap != null )			{				removeChild( leaveBitmap );				leaveBitmap = null;			}						if ( leaveTextField != null )			{				removeChild( leaveTextField );				leaveTextField = null;			}						if ( gameTimer != null )			{				gameTimer.start();			}		}				public function clearPathArray( thisArray:Array ):void		{			var i:int = thisArray.length - 1;						while ( i > -1 )			{				removeChild( thisArray[i] );				thisArray.splice( i, 1 );				i = i - 1;			}		}	}}